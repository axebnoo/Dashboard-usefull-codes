import React, { useState, useEffect } from 'react';
import {
    LineChart,
    Line,
    CartesianGrid,
    XAxis,
    YAxis,
    Tooltip,
    ReferenceArea,
    ResponsiveContainer,
    Legend
} from 'recharts';
import moment from "moment";
import { Button } from "antd";

const GraphLineNormal = (props) => {

    const [graphData, setGraphData] = useState({
        data: [],
        left: 'dataMin',
        right: 'dataMax',
        refAreaLeft: '',
        refAreaRight: '',
        animation: true,
        yAxisMin: 0,
        yAxisMax: 0,
        yAxisUnit: ''
    });

    useEffect(() => {
        const itemMinValues = props.dataSub?.map(item => item.itemMin);
        const itemMaxValues = props.dataSub?.map(item => item.itemMax);
        const itemUnit = props?.dataSub[0]?.unit;

        let minValue = Math.min(...itemMinValues);
        let maxValue = Math.max(...itemMaxValues);

        const updatedGraphData = {
            ...graphData,
            data: props.data,
            yAxisMin: minValue,
            yAxisMax: maxValue,
            yAxisUnit: itemUnit
        };

        setGraphData(updatedGraphData);
    }, [props.data]);

    const zoom = () => {
        let { refAreaLeft, refAreaRight } = graphData;
        const { data } = graphData;

        if (refAreaLeft === refAreaRight || refAreaRight === '') {
            setGraphData((prevState) => ({
                ...prevState,
                refAreaLeft: '',
                refAreaRight: '',
            }));
            return;
        }

        if (refAreaLeft > refAreaRight) [refAreaLeft, refAreaRight] = [refAreaRight, refAreaLeft];

        setGraphData((prevState) => ({
            ...prevState,
            refAreaLeft: '',
            refAreaRight: '',
            data: data.slice(),
            left: refAreaLeft,
            right: refAreaRight
        }));
    };

    const {
        data,
        left,
        right,
        refAreaLeft,
        refAreaRight
    } = graphData;

    const formatXAxis = (value, pFormat) => {
        const objectWithName1 = data.find(item => item.id === value);
        return moment(objectWithName1.clock_date).format(pFormat ? pFormat : "MM-DD HH:mm:ss");
    }

    const getItemName = (itemid) => {
        const rowData = props.dataSub.find((p) => p.itemid == itemid);
        return rowData?.item;
    }

    const CustomTooltip = ({ active, payload, label }) => {

        if (active && payload && payload.length) {
            return (
                <div style={{
                    backgroundColor: '#ffffff',
                    border: '1px solid #ccd5d9',
                    boxShadow: '0 4px 20px 0 rgba(118, 141, 153, 0.5)',
                    padding: '10px 8px 8px'
                }}>
                    <div style={{ color: '#1f2c33', fontSize: '12px', fontFamily: 'Arial, Tahoma, Verdana, sans-serif' }}>
                        {formatXAxis(label, "MM-DD HH:mm:ss")}
                    </div>
                    {
                        payload.map((entry, index) => (
                            <div key={index}>
                                <div style={{ display: 'flex', alignItems: 'center' }}>
                                    <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                                        <div style={{ background: entry.color, width: '8px', height: '8px', borderRadius: '50%' }}>
                                        </div>
                                        <div style={{ paddingLeft: '5px', color: '#1f2c33', fontSize: '12px', fontFamily: 'Arial, Tahoma, Verdana, sans-serif' }}>
                                            {getItemName(entry.name)}
                                        </div>
                                    </div>
                                    <div style={{ paddingLeft: '10px', color: '#1f2c33', fontSize: '12px', fontFamily: 'Arial, Tahoma, Verdana, sans-serif' }}>
                                        {entry?.value.toFixed(4)}
                                    </div>
                                </div>
                            </div>
                        ))
                    }
                </div>
            );
        }
    };

    const renderLegend = (props) => {
        const { payload } = props;
        return (
            <ul
                className='graph-legend-scroll'
                style={{
                    listStyle: 'none',
                    padding: 0,
                    margin: 0,
                    overflowY: 'scroll',
                    overflowX: 'hidden'
                }}>
                <div style={{ height: '70px', marginTop: '10px' }}>
                    {
                        payload.map((entry, index) => (
                            <li key={`item-${index}`} style={{ display: 'inline-block', paddingLeft: '5px' }}>
                                <Button type="text" size='small' style={{ margin: 0, borderRadius: '1em', height: '18px' }}>
                                    <div style={{ display: 'flex', alignItems: 'center' }}>
                                        <div style={{ width: '7px', height: '7px', borderRadius: '50%', backgroundColor: entry?.color, marginRight: '5px' }}>
                                        </div>
                                        <div style={{ fontFamily: '"Inter", sans-serif', fontSize: '10px', color: '#6b757b', fontFamily: '"Inter", sans-serif' }}>
                                            {entry?.item}
                                        </div>
                                    </div>
                                </Button>
                            </li>
                        ))
                    }
                </div>
            </ul>
        );
    }

    const getDivider = () => {
        let pDivider = 10;
        if (props?.widget?.id == 0) {
            pDivider = 10;
        } else {
            if (props?.widget?.layout?.w) {
                switch (props?.widget?.layout?.w) {
                    case 1:
                        pDivider = 1;
                        break;
                    case 2:
                        pDivider = 4;
                        break;
                    case 3:
                        pDivider = 8;
                        break;
                    case 4:
                        pDivider = 10;
                        break;
                    case 5:
                        pDivider = 15;
                        break;
                    case 6:
                        pDivider = 18;
                        break;
                    case 7:
                        pDivider = 20;
                        break;
                    case 8:
                        pDivider = 22;
                        break;
                    case 9:
                        pDivider = 22;
                        break;
                    case 10:
                        pDivider = 10;
                        break;
                    case 11:
                        pDivider = 30;
                        break;
                    case 12:
                        pDivider = 50;
                        break;
                    default:
                        pDivider = 9;
                        break;
                }
            }
        }
        const tickInterval = Math.ceil(data.length / pDivider);
        return tickInterval;
    }


    const onFormatYAxis = (pLabel) => {
        if (pLabel % 1000 === 0 && pLabel !== 0) {
            return (pLabel / 1000) + ' K';
        } else {
            return pLabel;
        }
    }

    const onYAxisTickCount = () => {
        let pDivider = 8;
        if (props?.widget?.id == 0) {
            pDivider = 8;
        } else {
            if (props?.widget?.layout?.h) {
                switch (props?.widget?.layout?.h) {
                    case 5:
                        pDivider = 4;
                        break;
                    case 6:
                        pDivider = 5;
                        break;
                    case 7:
                        pDivider = 5;
                    case 8:
                        pDivider = 6;
                        break;
                    case 9:
                        pDivider = 6;
                        break;
                    case 10:
                        pDivider = 9;
                        break;
                    default:
                        pDivider = 8;
                        break;
                }
            }
        }
        return pDivider;
    }

    return (
        <div style={{ userSelect: 'none', width: '100%', height: '100%' }} >
            <ResponsiveContainer>
                <LineChart
                    margin={{ bottom: 30, right: 10 }}
                    data={data}
                    onMouseDown={(e) => setGraphData({ ...graphData, refAreaLeft: e?.activeLabel })}
                    onMouseMove={(e) => graphData.refAreaLeft && setGraphData({ ...graphData, refAreaRight: e?.activeLabel })}
                    onMouseUp={zoom}
                >
                    <CartesianGrid stroke="#dedede" strokeDasharray="2 2" />

                    <XAxis
                        allowDataOverflow
                        dataKey="id"
                        domain={[left, right]}
                        type="number"
                        style={{
                            fontSize: '10px',
                            fontFamily: '"Inter", sans-serif',
                            fill: '#6b757b'
                        }}
                        stroke="#dedede"
                        ticks={data.map((entry, index) => (index % (getDivider()) === 0) ? entry.id : null)}
                        interval={0}
                        tickFormatter={(tick) => formatXAxis(tick, "HH:mm")}
                        angle={-90}
                        textAnchor="end"
                    />

                    <YAxis
                        style={{
                            fontSize: '10px',
                            fontFamily: '"Inter", sans-serif',
                            fill: '#6b757b'
                        }}
                        dx={5}
                        stroke="#dedede"
                        tickCount={onYAxisTickCount()}
                        unit={" " + graphData?.yAxisUnit}
                        allowDataOverflow={true}
                        domain={[graphData?.yAxisMin, 'auto']}
                        tickFormatter={onFormatYAxis}
                    />

                    <Tooltip content={<CustomTooltip />} />

                    <Legend
                        // payload={props?.dataSub?.filter((r, index) => index < 5)}
                        payload={props?.dataSub}
                        content={renderLegend}
                    />

                    {props.dataSub?.length > 0 ? (
                        props.dataSub?.map((r, index) => {
                            return (
                                <Line
                                    key={index}
                                    dataKey={r?.itemid}
                                    stroke={r?.color}
                                    dot={false}
                                    connectNulls={true}
                                />
                            );
                        })
                    ) : null}

                    {refAreaLeft && refAreaRight ? (
                        <ReferenceArea x1={refAreaLeft} x2={refAreaRight} strokeOpacity={0.3} />
                    ) : null}

                </LineChart>
            </ResponsiveContainer>
        </div>
    );
};

export default GraphLineNormal;
